# Get all graph nodes and links
MATCH (n) 
MATCH (m) 
MATCH p=(n)-[:Influences*..]->(m) 
WITH *, relationships(p) AS relations 
RETURN [relation IN relations | [startNode(relation), (relation), endNode(relation)]] as data 

# Filter for influence area(s)
MATCH (n) 
MATCH (m) 
MATCH p=(n)-[r]->(m) 
WHERE 'sport' IN r.influence_areas
WITH *, relationships(p) AS relations 
RETURN [relation IN relations | [startNode(relation), (relation), endNode(relation)]] as data

# Filter for influence scores
MATCH (n) 
MATCH (m) 
MATCH p=(n)-[r]->(m) 
WHERE 0 <= toInteger(r.all_influence_score) <= 10
WITH *, relationships(p) AS relations 
RETURN [relation IN relations | [startNode(relation), (relation), endNode(relation)]] as data 

# All paths between to nodes by name
MATCH (n {name: 'User G'})
MATCH (m {name: 'User F'})
MATCH p=(n)-[:Influences*..]->(m)
WITH *, relationships(p) AS relations
RETURN [relation IN relations | [startNode(relation), (relation), endNode(relation)]] as data

# Shortest path between to nodes by name
MATCH (n {name: 'User G'})
MATCH (m {name: 'User B'})
MATCH p=shortestPath((n) - [:Influences* ..] -> (m))
WITH *, relationships(p) AS relations 
RETURN [relation IN relations | [startNode(relation), (relation), endNode(relation)]] as data

# graph density
match(n)-[r]-() 
return round( toFloat(count(distinct r)) / toFloat(count(DISTINCT n)*(count(DISTINCT n)-1) ), 2) AS density

# Centrality
--------------------------------------------------------------------------------------------------------

****************************** Normalized Degree Centrality ******************************
# Graph type => disconnected, Weighted, directed graph
# Use Case   => determining the most influential person
--------------------------------------------------------------------------------------------------------
MATCH()-[r]->() 
CALL gds.alpha.degree.stream({ 
    nodeProjection: 'Redditor', 
    relationshipProjection: {
        Influences: {
            type: 'Influences',
            properties: 'all_influence_score'
        }
    }, 
    relationshipWeightProperty: 'all_influence_score'
})
YIELD nodeId, score 
RETURN gds.util.asNode(nodeId).name AS name, score/sum(r.all_influence_score) as centrality
ORDER BY centrality DESC
--------------------------------------------------------------------------------------------------------

****************************** Normalized Betweensness Centrality ******************************
# Graph type => disconnected, Unweighted, directed graph
# Use Case   => Detecting the ability of each influencer node to act as a bridge in spreading information across the network
====> Who can help spread the information from A to B?

MATCH p=shortestPath((n)-[:Influences* ..]->(m))
WHERE n.name <> m.name
CALL gds.betweenness.stream({
  nodeProjection: 'Redditor',
  relationshipProjection: 'Influences'
})
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, round(score/count(p), 3) as centrality
ORDER BY centrality DESC

--------------------------------------------------------------------------------------------------------


/// stopped here last time

****************************** Hermonic-Closeness Centrality ******************************
# Graph type => disconnected, Unweighted, undirected graph
# Use Case   => Where to influence or put information for maximum or better spread of information
====> Who or Where to influence for better spread of information?

CALL gds.alpha.closeness.harmonic.stream({
  nodeProjection: 'Redditor',
  relationshipProjection: 'Influences'
})
YIELD nodeId, centrality
RETURN gds.util.asNode(nodeId).name AS name, centrality
ORDER BY centrality DESC
--------------------------------------------------------------------------------------------------------